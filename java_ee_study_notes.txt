#
##
### Chapter 1 Intro to Java EE
  Intro to Servlet, Filter, Listener, JSP
  understand WAR, EAR files and different ClassLoader Architectures

classLoader
   isolating the web application from others on the same server.

code for my web application + thrid party library code

Java Servelt
   Java class responsible for accepting and responding to HTTP requests.

Filter
   Java EE component that intercepts HTTP request to your Servlet.

Listener

JSP

Life cyle of Jave web app
  create, kill, listener, etc

JAR vs. WAR vs. EAR	
  each archives come with different ClassLoader Architecture

Tag library descriptor

Tomcat use context.xml(Deployment Descriptor) to descript how to deploy the application.

WEB-INFO + META-INFO

Annotation vs. Java Configuration API
   used to configure web aplication, 

Web Fragment
   JAR files in your web app

ClassLoader archicture:
  Classloader -> Extension classloader -> application classloader
  Parent-frist(Java app) vs parent-last(Java EE app)

#
##
### Chapter 2 Using Web Container


web container == servlet container (implements only Servelt, JSP, JSTL specification. ie. GlassFish, Tomcat) vs. application server (implments all Java EE specification)
  application server contains web container
  web container can be used on: manage Servlet life cycle, map URL to Servlet code, accept/response HTTP request, manage Filter chain, 

Tomcat:
  partical Java EE implementation:
    Servlet
    Java Server Page
    Java Unified Expression
    Websocket


GlassFish:
  full Java EE implementation


List of web container:
  Tomcat, Jetty, Tiny

List of Application Server:
  GlassFish, WildFly, JOnAS, Resin, Caucho, Enhydra, Oracle WebLogic, IBM WebSphere,


Tomcat pratice:
  deploy web app
  undeploy web app
  debug web application from IDE
  setup Tomcat on IntelliJ
  add Tomcat configuration to a Project

#
##
### Chapter 3 Writing First Servlet
   Create a Servlet Class
   Configure a Servlet for deployment
   understand doGet(), doPost() and other methods
   using parameters and accepting form submission
   configure application using ini parameter
   upload files from a form
   make application safe for multithreading

Servlet:
  Servlet is core classes in any web application, handles HTTP request or deletge it to other part of aplication
  Web container also contains built-in Servlets
  extends HttpServlet and GenericSerlvet, need to overload the doGet(), doPost() methods, etc

HttpServlet:
  its methods take arguments(HttpServletRequest, HttpServletResponse)

The Web Container interpretes the HTTP request in doGet() and reads the headers and parameters from the WebSocket. After the method finished, it also formates the response header and body and write them back to the socket

Initializer and Destroyer:
  init() is called after Servlet is contructed, but before it can response to the first request
    after the Servlet is set, you can have access to ServletConfig and ServletContext object
    can use init() method to read a properties file or connect to a database using JDBC
  destory() is called when the Servlet no longer accepting request

ServletConfig class:


Configuring a Servlet for deployment:
  deployment descriptor(Add the servlet to the descriptor):
    it is a web.xml file
    instructs the Web Container how the application should be deployed
    defines all the Servlet, listener, filter should be depolyed with the application
    defines the settings for the web application 
  (Map the Servlet to URL):
    different URLs can map to same Servlet
    same Servlet class can have different Servlet name, ie. two Servlet can have identical logic, but connecting to different database

The Servlet's service() mehthod services all incoming request.
   service() understands the headers and parameters that the client sends and then return proper HTTP response 
   service method enables you:
     read parameter passed from client
     accept uploaded files from a posted form
     read raw data contained in the request body(ie. handle PUT request, accept JSON request body)
     read request header/manipulate response header/write response content back to client



doGet(), doPost(), doPut(), etc and all the service method returns empty HTTP response by default

Using HttpServletRequest:
  HttpServletRequest can retrieve request parameter, which is passed by the client
  Request Parameter has two form:
    query parameter == URI parameter (ie. GET /index.jsp?productId=9781118656464&category=Books HTTP/1.1)
    post varialbe == form varialbe == encoded request body, (ie. application/x-www-form-urlencoded or multipart/form-data encoded request body)
      POST /index.jsp?returnTo=productPage HTTP/1.1
	  Host: www.example.com
	  Content-Length: 48
	  Content-Type: application/x-www-form-urlencoded
	  addToCart&productId=9781118656464&category=Books
  methods for retrieving Request Parameter:
    getParameter, getParameterMap, getParameterNames, getParameterValues, 
  Content of Request
  Request characteristics: URL, URI, and headers
    getHeader, getHeaderNames, getSession, getCookie, etc


Using HttpServletResponse:
  set response header, write to response body, redirect request, set HTTP status code, send cookie back to client/

 # 12/04

accepting form submission:
  ie. using @WebServelt annotation on class HelloServlet 

configuring application and its Servlet using Initialization Parameters:
  using context init parameter (also called init parameter)
  using Servlet init parameter
  define information about connecting to a relational database
  provide email address to send store alert to.
  init parameters define at the application startup, and can't change without restarting the application

  parameters in the xml can be change without restarting the application

Annotation-based configuration:
  pro: no xml, concise annotation lanuage, define ordering for Filter, define error-handling page, configure JSP setting, provide a list of welcome page.
  con: can't create multiple instance of single Servlet class,

Uploading files from a Form:
  it was a complex procude in Java EE, Apache make Commons FileUpload to handel the work
  Servlet 3.0 introduces getPart() and getParts() in HttpServletRequest


Customer Support Project:
  allow users to post questions or suppport tickets
  enable employee to respond to the inquries
  support ticket and comments have file attatchments.
  provide a chat windows with customer rep
  support internationalization
  secure

Create the Servlet for File Uploades
  Ticket Class (POJO)
  Attatchment Class (POJO)
  TicketServlet class:
    @WebServlet
    @MultipartConfig

Accepting a file upload:
  


Makine web application multithread safe:
  web container has thread pool(also called connector poool, executor pool)
  Request will goes into a first-in-first-out queue for thread execution, when the thread pool in web container is full.
  Tomcat has a thread pool of 200 by default.

Protecting shared resource:
  static and instance variable in Servlet can be accessed by multiple threads simultaneously
  access to shared resources should be synchronized
  volatile keyword (ie. private volatile int TICKET_ID_SEQUENCE = 1;)
  use synchronized bloack (no thread can execute the lines of code at the same time)

Warning: never store request/response objects in static or instance variable.

#
##
### Chapter 4 using JSPs to Display Content
  using <br /> is easier than output.println("<br />")
  creating first JSP
  using Java within JSP(and why you shouldn't)
  combining Servlet and JSP
  A note about JSP Document JSPX

Why JSP
  JSP can contain:
    HTML
    Java code
    biult-in JSP tags
    custom JSP tags
    Expression Language (EL)

JSP life cycle:

syntax
directive:
  <%@ this is a directive %>
  used to direct JSP interpreter: 
    to perform an action (such as setting the content type), 
    to import a class, 
    to include other JSP at translantion time,
    include a JSP tag library.

declaration:
  <%! this is declaration %>
  contains Java code
  used to declare something within the scope of your JSP Servlet class:
    define instance varialbe, methods, or classes within a delaration tag
    declaration are inner classes of the JSP Servlet class

scriptlet:
  <% this is a scriptlet %>
  contains Java code
  class and variable defined within scriptlet can't be used within a delcartion. 
  Scriptlet codes are copied to the body of _jspService method
  define local variable, but not instance field:
    you can use conditional statement, manipulate object, perform arithmetic, and all other things you cant do in JSP delcartion.
  

expression:
  <%= this is express %>
  contains simple Java code that can return something that can be written to the client output.
  contains expression output 
  Expression has the same scope as scriptlet, codes are copied to _jspService()


JSP vs JSF(Facelet) vs other templating frameworks(Velocity, FreeMarker, SiteMesh, Tiles)

JSP code -> Java Code -> bytecode -> machinecode

JSP is a syntax-sugared Servlet class

Create your first JSP:
  understand the file structure:
    4 JSP tags
  commentingi JSP code:
    XML comment == HTML comment (ie.  	<!-- this is HTML/XML comment -->), JSP codes inside HTML comment will be evaluted, also will be snet to brower
    Java line comment
    Java block comment
    JSP comment (ie. <%-- this is JSP comment -->), not interpreted by JSP compiler and not send to broswer


Addding import to JSP:
  using page directive to import Java class (ie. <%@ page import="java.util.*" %>)

Using directive:
  3 types of directives:
    (change page Properties) page directive:
      provides control over how the JSP is translated, rendered, and transimitted back to the client
      (ie. pageEncoding, session, isELIgnored, buffer and autoFlash)
        no buffer can improve performance of JSP, because it decrease memory consumption, and CPU overhead.
        no buffer can result in sending more packets back to the client.
      (more ie. errorPage, isErrorPage, isThreadSafe, extends)
    (include other JSPs) include directive:
      (ie. <%@ include file="path/to/some/file.jsp" %>, path can be relative/absolute), include directive is translated at compile time for once only
      can be done using <jsp:include> tag (ie. <jsp:include path="path/to/some/page.jsp" />), the included file is translated separately.
      At run time, the request is temporarily forwarded to the include JSP, the resulting output of the JSP of that JSP is written to the response, and then the control returns back to the including JSP.
    (including tag library) 
      taglib directive can be used to reference a tag library, so that you can use the tags defined by the tag library in your JSP.
      ie. <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
      will goes into detial on Chater 7

using <jsp> tag:
  all JSPs support a special kind of tag with an XMLNS prefix of jsp.
    ie. <jsp:forward page="/path/to/some/page.jsp"> forwards a request from the JSP it is currently executing in to some other JSP. Anything the JSP writes to the responses stays in the response when the forward occurs. Partial result written to the the response will be erased, if you are using a redirect.
    ie. <jsp:useBean> tag declares the presense of a JavaBean on the page
      instantiates a class to create a bean
      this bean can be accessed using other two bean tags, custom tags, and JSP scriptlets and expressions.
      Advantages of declaring a bean this way is:
        beans can be accessed to other JSPs.
        if beans are declaried in scriptlet, it can only be used by scriptlets and expressions.
    ie. <jsp:getProperty> tag retrieves properties from beans declared with <jsp:useBean>
    ie. <jsp:setProperty> tag sets the property(using setter methods)
    ie. <jsp:plugin> tag, it is a tool for embedding Java Applets in rendering HTML, <jsp:plugin type="applet" code="MyApplet.class" jreversion = "1.8">

 Using Java within JSP (and why you shouldn't)
   using the implicit varialbes in a JSP:
     JSP files have implicity variables(object) for use within scriptlets and expressions (it is defined by the JSP specification)
     The variables have method scope
       means, you can't use them within any code JSP declaration, because declartion have class scope.
     total of 9 implicit variables:
       request/response:
	     both are instances of HttpServletRequest and HttpServletResponse
	     anythings you can do with Servlet, you can do it in JSP
	   session:
	     this variable is an instance of HttpSession
	   out:
	     this is a JspWriter instance
	   application:
	     this is a instance of ServletContext interface. gives you access to the configuration of the web application as a while, including all the context init parameter
	   config:
	     is an instance of the ServletConfig interface. can be used to access the configuration of the JSP Servlet, such as the Servlet init Parameter
		pageContext:
		  it an instance of PageContext class, provides serveral convenience methods for getting request attribues, and session attributes, accessing the request and response, including other files, and forwading the request. 
		  usually being used for writing cusom JSP tags
	    page:
	      this is the this variable from theJSP Servlet object. 
	    exception:
	      this variable is available after setting the isErrorPage to true
  Why you shouldn't use Java in a JSP
    Pro: things you can do using Java, can be done in JSP
      ie. connect to, query, manipulate a database
      ie. access and wirte to files on the server file system.
      ie. sort a binary tree with one billion nodes
    Con: JSP is designed for the presentation layer, also know as the view.
      ie. presentation layer should be separated from the buiness logic. 

  Combining Servlets and JSPs
    you need this for handling complex logic, data validation, data persistence, and a detailed presentation layer.
    configuring JSP properties in the Deployment Descriptor:
      use web.xml
      add <jsp-config>
        add <jsp-property-group>
      <url-pattern> in both a <servlet-mapping> vs <jsp-property-group>
      if the <url-pattern> tag is identical, <jsp-property-group> wins over the Servlet mapping.
      if some files matches a <url-pattern> in more than one JSP property group and more than one of those property groupd contains <include-prelude> or <include-coda> rules, the indlue rules from all the JSP peoperty groups are applied for that file.

  Using JSP Properties
    ie. <include-prelude> and <include-coda>
    ie. <page-encoding>
    ie. <trim-directive-whitespaces>
    ie. <scripting-invalid>, <el-ignored>
  Forwarding a request from a Servlet to a JSP
    ie. to have the Servlet accept the request, do business logic processing and data storage or retrieval, prepare a model that can easily to be used in a JSP, and then forward the request to the JSP
    ie. use the Request Dispatcher -> request.getRequestDispatcher("/WEB-INF/jsp/view/ticketForm.jsp").forward(request, response);
    ie. design for the presentation layer
    "request attribute" is not the same as request parameter:
      request attribute is object while request parameter is Strings.
      request attribute is for internal use within your web application

  JSP Document vs JSP
    JSPX works with pure XML, but it has more strict schema or they will fial to parse.
    JSPX can be slightly easier to detect problems with the JSP at compile time instead of run time.


#
##
### Chapter 5 Maintaining State Using Sessions
  Why sessions are necessary
  working with cookies and URL parameters
  How to store data in a session
  Making sessions usefull
  How to cluster an application that uses sessions

Why session is necessary:
  associate multiple requests coming from the same client
  share data between those requests
  Sessions are used to maintain state between one request and the next.
  remembering users
  enabling application workflow

Using session cookies and URL rewriting:
  A session is some file, memory segment, object or container managed by the server or web application that contains various data elementes assigned to it. These data elements sould be a username, a shopping cart, workflow details, and more.
  Session ID is the link between the server and browser.
  Session Cookie:
    also called HTTP cookie:
   	  stores various attributes, such as a domain name, a pth, an expiratio date or maximum age, a secure flag, and an HTTP-only flag
   	    domain attribute:
   	      instructs the brower for which doamin names it should send the cookied back
   	    path attribute:
   	      enables the cookie to further be restricted to a certian URL relative to the domain
    web server use cookies to store session IDs on the client side


# day 3, 12/05

  ways of making cookie works:
    1. store Session ID cookie on client side, server send the cookie to client for once, and client has to send back the cookie everytime if connects back to server.
    2. transimit Session ID through URLs, so you can avoid using cookie
      ie. the session ID is embedded in the Location header URI and in every single URL in the markup.
      Java EE Servlet API makes embedding seesion ID simple:
        encodeURL()
        encodeRedirectURL()
    3. using <c:url> tag


  Session Vulnerabilities:
    copy and paste on session ID embedded URL
      cookie is more safe for this case
    session fixation
      hacker get the session ID embedded URL and let victim use it
        use session migration:
          change session ID after victim logged in
    cross-site scripting and session hijacking
      hacker use JS to read the session ID and assuming the identiy of the victim.
      session ID cookied should include the HttpOnly attribute(making brower to use cookie only on HTTP/HTTPS request) (this prevents JS accessiong Session, but not Ajax, because brower is responsible for formating the Ajax request header)
    Insecure Cookies:
      hackers intercepts request and response between the client and server. this gave rise to Secure Socket Layer and Transport Layer Security and HTTPS protocol.
      need to use HTTPs all the time to make this secure
  
  The strongest defense:
    SSL/TLS session ID
    web container will not know what the SSL session ID is, because if you use a web server or load balancer to mange your SSL in a clusterd server environemtns.


Storing Data in a session:
  configure sessions in the web.xml:
    <session-config>, <cookie-config> or use ServletContext 
  Storing and retrieving data:
  using session in your servlet:
  using session in your JSP:

Storing more complex data in sessions:
 

Applying Session usefully:
  Adding login to the Customer Support Application:
  Detecting changes to sessions using listeners:
    session event(when changes are made to sessions, the web container can notify your application of these chagnes):
      using publish-and-subscribe model(separete code that checks session changes, and code that makes change to session)
        listener (code that detects changes) listen to some form of session activity 
          3 methods of registering listener
            1. annotate with @WebListener 2. Declare in web.xml 3. register it using ServeltContext's addListener()
          ie. you subscribe to an event by implemtn the listener interface
          ie. something happens that triggers the publication of an event to which your code is subscribed -> the container invokes the method on your class corresponding to that event.
        sessionID will change after you login and logout, for safety
        Note: when Tomcat is restarted, you will see the sessions from previous runtime. Tomcat tries to restore the serialized sessions to memory.

Maintaining a list of active sessions:
  creating a SessionREgistry class:
    adding a reference to the Sessions, because sessions stored on memory is for other purpose.


Clustering an application that uses sessions:
  If your application runs on different Tomcat instances, you may see different sessions listed. 
  If you want to see all sessions on all different Tomcat instances, you need:
    configure application for clustering
    setup session replication in your web container
  Pro: redundancy, scalability
  Con: passing message between instance of an application running on separate machines
    AMQP, JMS, MSMQ

  What is Load Balancing?
    ie. round-robin, load-smart


  Using SessionID in a cluster:
    if two consecutive request from same client go to different web container. Each one has a different session ID, which means that session is useless
    one solution to this problem is:
      employee sticky session:
      	Sticky session is that the load balancing mechanism is session-aware and always sends a request form the same session to the same server.

#
##
### Chapter 6 Using Expression Language in JSPs
  EL syntax
  how to use scoped variables in EL expressions
  how to access collections with JAva 8 stre4ams in EL expression
  switching out Java code with Expression Language

Expression Language (EL expressions when the JSP is rendered)
  base syntax:
    immediate evaluation: it is EL expression that the JSP engine should parse and evaluate at the time of page rendering
      ${expr}

    deferred evaluation: it is EL expression that supports the needs of JavaServer Faces most of the time.
      #{expr}
  Placing EL expressions:
    can be used within standard HTML tag attribute, <input type="text" name="something" value="${expr}" />
    can be used within JSP tag attribute, <c:url value="/something/${expr}/${expr}" />

Writing with the EL syntax, what you can put within an EL expression:
  EL is designed to provide you with tools you need to create JSPs without Java.

Collection literal type:
  you can construct Sets, Lists, Maps
  literal Set -> HashSet<Object>
  literal LIst -> ArrayLIst<Object>
  literal Map -> HashMap<Object, Object>

Object Properties and Methods:
  ${shirt.size}
  ${shirt["size"]}
  ${shirt["styleCategory"]}

EL functions:
  in EL, a function is a special tool mapped to a static method on a class.
    ie. ${[ns]:[fn]([a1[, a2[, a3[, ...]]]])}

Static Field and Method Access:
  ie. ${java.lang.Integer.MAX_VALUE}
  access static field, method of class

Enums:
  ie. ${dayOfWeek == java.time.DayOfWeek.SATURDAY}

Lambda Expressions:
  ie. ${v = (a, b) -> a + b; v(3, 15)}
  ie. ${users.stream().filter(u -> u.lastName == 'Williams' || u.lastName == 'Sanders ').toArray()}

Collections:
  ${map["username"]}
  ${map["userId"]}
  ${map.username}
  ${map.userId}
  you can't access Sets and Queues Collection type using Expression Language

Using Scoped variables in EL expressions:
  EL has set of implicit variable (10 of them is Map object) (just like JSPs have 9 implicity variables)
  also has implicit scope in which unknown vaiables are resolved.
  4 different attribute scope
    page: encapsulates attributes for a particular page JSP and request. variable bound to page scope only availabe to that JSP and its life request. It is the JspContext or PageContext object.
    request: exists anywhere that has access to the request object, and the attributes bound to the request are no longer bound after the request completes.
    session: 
    application: existing across all request, sessions, JSP pages, and Servlets. It is the ServletContext object

Using the implicit EL scope:
  EL defines 11 implicity variables.
    used to resolve an attribute in the request, session, page or application scope.
    How EL evaluator resolves the variable:
      1. checks if the variable is one of the 11 implicity variables
      2. if not, EL evaluator next looks for an attribute in the page scope, PageContext.getAttribute("variable")
      3. if finding no matching page attribute, the valuator looks for request attribute, HttpServletREquest.getAttribute("variable")
      4. """, looks for session attribute HttpSession.getAttribute("variable")
      5. """, looks for application attribute, ServletContext.getAttribute("variable")
      6. if finding no matching on all 4 scope, raise an error
    why this feature is useful:
      no need to retrieve an instance of the HttpServletREquest or HttpSession to use attributes on either of these objects
      ie. Username: ${user.username} (${user.username.length()} characters) <br />
      ie. Full Name: ${fn:escapeXml(user.lastName += ', ' += fn:escapedXml(user.firstName))}
      ie. if we change to request.getSession().setAttribute("user", user);, this will still works. The user attribute will be in session scope, instead of request.
      ie. change to this.getServletContxt().setAttribute("user", user); will also work

Using the 11 implicit EL variables:
  pageContext: an instance of the PageContext class. can access the page error data and exception object, the expression evaluator, the output writer, the JSP Servlet instance, the request and response, the ServletContext, the ServletConfig, and the session.
  pageScope: is a Map<String, Object> containing all the attributes bound to the pageContext.
  requestScope: is a Map<String, Object> of all the attributes bound to the ServletRequest. Using this, you can access these attributes without calling a method on the request object
  sessionScope: contains all the session attribues from the current session.
  applicationScope: contains all the attributes bound to the ServletContext instance.
  param and paramValues: both provide access to the request parameter.
  header and headerValues: provide access to the request header.
  initParam: contains all the context init parameter from ServletContext intance for this application
  cookie: contains all the cookied that the user's browwer sent along with the request. is a Map<String, javax.servlet.http.Cookie>. More than one cookie can have the same name, but different path. You need to iterate over all the cookies in order to get the duplicate cookie.


Accessing Collections with Stream API:
  

